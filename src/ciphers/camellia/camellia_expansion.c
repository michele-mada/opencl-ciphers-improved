#include "camellia_expansion.h"


const uint64_t Sigma1 = 0xA09E667F3BCC908Bul;
const uint64_t Sigma2 = 0xB67AE8584CAA73B2ul;
const uint64_t Sigma3 = 0xC6EF372FE94F82BEul;
const uint64_t Sigma4 = 0x54FF53A5F1D36F1Cul;

// only used for keylen > 128
const uint64_t Sigma5 = 0x10E527FADE682D1Dul;
const uint64_t Sigma6 = 0xB05688C2B3E6C1FDul;


uint64_t rol128lo(uint64_t xhi, uint64_t xlo, unsigned n) {
    if (n > 64) {
        return n? (xhi << (n - 64)) | (xlo >> (128 - n)) : xhi;
    } else {
        return n? (xlo << n) | (xhi >> (64 - n)) : xlo;
    }
}

#define rol128hi(xhi, xlo, n) rol128lo(xlo, xhi, n)


uint64_t F(uint64_t F_IN, uint64_t KE) {
    uint64_t x;

    uint8_t t1, t2, t3, t4, t5, t6, t7, t8;
    uint8_t y1, y2, y3, y4, y5, y6, y7, y8;

    x  = F_IN ^ KE;

    t1 =  x >> 56;
    t2 = (x >> 48) & 0xFF;
    t3 = (x >> 40) & 0xFF;
    t4 = (x >> 32) & 0xFF;
    t5 = (x >> 24) & 0xFF;
    t6 = (x >> 16) & 0xFF;
    t7 = (x >>  8) & 0xFF;
    t8 =  x        & 0xFF;

    t1 = sbox1[t1];
    t2 = sbox2[t2];
    t3 = sbox3[t3];
    t4 = sbox4[t4];
    t5 = sbox2[t5];
    t6 = sbox3[t6];
    t7 = sbox4[t7];
    t8 = sbox1[t8];

    y1 = t1 ^ t3 ^ t4 ^ t6 ^ t7 ^ t8;
    y2 = t1 ^ t2 ^ t4 ^ t5 ^ t7 ^ t8;
    y3 = t1 ^ t2 ^ t3 ^ t5 ^ t6 ^ t8;
    y4 = t2 ^ t3 ^ t4 ^ t5 ^ t6 ^ t7;
    y5 = t1 ^ t2 ^ t6 ^ t7 ^ t8;
    y6 = t2 ^ t3 ^ t5 ^ t7 ^ t8;
    y7 = t3 ^ t4 ^ t5 ^ t6 ^ t8;
    y8 = t1 ^ t4 ^ t5 ^ t6 ^ t7;

    uint64_t F_OUT = ((uint64_t)y1 << 56)
                   | ((uint64_t)y2 << 48)
                   | ((uint64_t)y3 << 40)
                   | ((uint64_t)y4 << 32)
                   | ((uint64_t)y5 << 24)
                   | ((uint64_t)y6 << 16)
                   | ((uint64_t)y7 <<  8)
                   | y8;
    return F_OUT;
}


// generate 64-bit subkeys kw1, ..., kw4, k1, ..., k18, ke1, ..., ke4
// the subkeys are concatenated stored concatenated into a single array
// exkey = kw | k | ke
void camellia_expandkey(uint64_t *user_key, camellia_context *context, size_t keylen) {
    uint64_t K[4];
    uint64_t *enc_kw, *enc_k, *enc_ke;
    uint64_t *dec_kw, *dec_k, *dec_ke;

    K[0] = user_key[0]; K[1] = user_key[1];

    if (keylen == 128) {
        K[2] = 0; K[3] = 0;
    } else if (keylen == 128) {
        K[2] = user_key[2]; K[3] = ~user_key[2];
    } else {
        K[2] = user_key[2]; K[3] = user_key[3];
    }

    uint64_t KLhi = K[0];
    uint64_t KLlo = K[1];
    uint64_t KRhi = K[2];
    uint64_t KRlo = K[3];

    uint64_t D1, D2;

    D1 = KLhi ^ KRhi;
    D2 = KLlo ^ KRlo;
    D2 = D2 ^ F(D1, Sigma1);
    D1 = D1 ^ F(D2, Sigma2);
    D1 = D1 ^ KLhi;
    D2 = D2 ^ KLlo;
    D2 = D2 ^ F(D1, Sigma3);
    D1 = D1 ^ F(D2, Sigma4);

    uint64_t KAhi = D1;
    uint64_t KAlo = D2;

    if (keylen > 128) {
        D1 = KAhi ^ KRhi;
        D2 = KAlo ^ KRlo;
        D2 = D2 ^ F(D1, Sigma5);
        D1 = D1 ^ F(D2, Sigma6);
    }


    // only used for keylen > 128
    uint64_t KBhi = D1;
    uint64_t KBlo = D2;

    // 64-bit subkeys are generated by rotating KL, KR, KA, and KB and
    // taking the left- or right-half of them.

    if (keylen == 128) {
        camellia18_context *ctx = &context->key18;
        enc_kw = ctx->esk; enc_k = ctx->esk + 4; enc_ke = ctx->esk + 22;
        dec_kw = ctx->dsk; dec_k = ctx->dsk + 4; dec_ke = ctx->dsk + 22;

        enc_kw[0] = dec_kw[3] = rol128hi(KLhi, KLlo,   0);
        enc_kw[1] = dec_kw[2] = rol128lo(KLhi, KLlo,   0);

        enc_k[0]  = dec_k[17] = rol128hi(KAhi, KAlo,   0);
        enc_k[1]  = dec_k[16] = rol128lo(KAhi, KAlo,   0);
        enc_k[2]  = dec_k[15] = rol128hi(KLhi, KLlo,  15);
        enc_k[3]  = dec_k[14] = rol128lo(KLhi, KLlo,  15);
        enc_k[4]  = dec_k[13] = rol128hi(KAhi, KAlo,  15);
        enc_k[5]  = dec_k[12] = rol128lo(KAhi, KAlo,  15);

        enc_ke[0] = dec_ke[3] = rol128hi(KAhi, KAlo,  30);
        enc_ke[1] = dec_ke[2] = rol128lo(KAhi, KAlo,  30);

        enc_k[6]  = dec_k[11] = rol128hi(KLhi, KLlo,  45);
        enc_k[7]  = dec_k[10] = rol128lo(KLhi, KLlo,  45);
        enc_k[8]  = dec_k[9]  = rol128hi(KAhi, KAlo,  45);
        enc_k[9]  = dec_k[8]  = rol128lo(KLhi, KLlo,  60);
        enc_k[10] = dec_k[7]  = rol128hi(KAhi, KAlo,  60);
        enc_k[11] = dec_k[6]  = rol128lo(KAhi, KAlo,  60);

        enc_ke[2] = dec_ke[1] = rol128hi(KLhi, KLlo,  77);
        enc_ke[3] = dec_ke[0] = rol128lo(KLhi, KLlo,  77);

        enc_k[12] = dec_k[5] = rol128hi(KLhi, KLlo,  94);
        enc_k[13] = dec_k[4] = rol128lo(KLhi, KLlo,  94);
        enc_k[14] = dec_k[3] = rol128hi(KAhi, KAlo,  94);
        enc_k[15] = dec_k[2] = rol128lo(KAhi, KAlo,  94);
        enc_k[16] = dec_k[1] = rol128hi(KLhi, KLlo, 111);
        enc_k[17] = dec_k[0] = rol128lo(KLhi, KLlo, 111);

        enc_kw[2] = dec_kw[1] = rol128hi(KAhi, KAlo, 111);
        enc_kw[3] = dec_kw[0] = rol128lo(KAhi, KAlo, 111);
    }
    else { // 192 or 256
        camellia24_context *ctx = &context->key24;
        enc_kw = ctx->esk; enc_k = ctx->esk + 4; enc_ke = ctx->esk + 28;
        dec_kw = ctx->dsk; dec_k = ctx->dsk + 4; dec_ke = ctx->dsk + 28;

        enc_kw[0] = dec_kw[3] = rol128hi(KLhi, KLlo,   0);
        enc_kw[1] = dec_kw[2] = rol128lo(KLhi, KLlo,   0);

        enc_k[0]  = dec_k[23] = rol128hi(KBhi, KBlo,   0);
        enc_k[1]  = dec_k[22] = rol128lo(KBhi, KBlo,   0);
        enc_k[2]  = dec_k[21] = rol128hi(KRhi, KRlo,  15);
        enc_k[3]  = dec_k[20] = rol128lo(KRhi, KRlo,  15);
        enc_k[4]  = dec_k[19] = rol128hi(KAhi, KAlo,  15);
        enc_k[5]  = dec_k[18] = rol128lo(KAhi, KAlo,  15);

        enc_ke[0] = dec_ke[5] = rol128hi(KRhi, KRlo,  30);
        enc_ke[1] = dec_ke[4] = rol128lo(KRhi, KRlo,  30);

        enc_k[6]  = dec_k[17] = rol128hi(KBhi, KBlo,  30);
        enc_k[7]  = dec_k[16] = rol128lo(KBhi, KBlo,  30);
        enc_k[8]  = dec_k[15] = rol128hi(KLhi, KLlo,  45);
        enc_k[9]  = dec_k[14] = rol128lo(KLhi, KLlo, 45);
        enc_k[10] = dec_k[13] = rol128hi(KAhi, KAlo,  45);
        enc_k[11] = dec_k[12] = rol128lo(KAhi, KAlo,  45);

        enc_ke[2] = dec_ke[3] = rol128hi(KLhi, KLlo,  60);
        enc_ke[3] = dec_ke[2] = rol128lo(KLhi, KLlo,  60);

        enc_k[12] = dec_k[11] = rol128hi(KRhi, KRlo,  60);
        enc_k[13] = dec_k[10] = rol128lo(KRhi, KRlo,  60);
        enc_k[14] = dec_k[9]  = rol128hi(KBhi, KBlo,  60);
        enc_k[15] = dec_k[8]  = rol128lo(KBhi, KBlo,  60);
        enc_k[16] = dec_k[7]  = rol128hi(KLhi, KLlo,  77);
        enc_k[17] = dec_k[6]  = rol128lo(KLhi, KLlo,  77);

        enc_ke[4] = dec_ke[1] = rol128hi(KAhi, KAlo,  77);
        enc_ke[5] = dec_ke[0] = rol128lo(KAhi, KAlo,  77);

        enc_k[18] = dec_k[5]  = rol128hi(KRhi, KRlo,  94);
        enc_k[19] = dec_k[4]  = rol128lo(KRhi, KRlo,  94);
        enc_k[20] = dec_k[3]  = rol128hi(KAhi, KAlo,  94);
        enc_k[21] = dec_k[2]  = rol128lo(KAhi, KAlo,  94);
        enc_k[22] = dec_k[1]  = rol128hi(KLhi, KLlo, 111);
        enc_k[23] = dec_k[0]  = rol128lo(KLhi, KLlo, 111);

        enc_kw[2] = dec_kw[1] = rol128hi(KBhi, KBlo, 111);
        enc_kw[3] = dec_kw[0] = rol128lo(KBhi, KBlo, 111);
    }
}
